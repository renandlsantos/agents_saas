---
description: 
globs: *.test.ts,*.test.tsx
alwaysApply: false
---
---
type: agent-requested
title: Guia de Testes - LobeChat Testing Guide
description: Guia de configuraÃ§Ã£o do ambiente de teste Vitest, mÃ©todos de execuÃ§Ã£o e princÃ­pios de correÃ§Ã£o para o projeto LobeChat
---

# Guia de Testes - LobeChat Testing Guide

## ğŸ§ª VisÃ£o Geral do Ambiente de Teste

O projeto LobeChat usa a biblioteca de testes Vitest, configurada com dois ambientes de teste diferentes:

### Ambiente de Teste Cliente (DOM Environment)

- **Arquivo de configuraÃ§Ã£o**: [vitest.config.ts](mdc:vitest.config.ts)
- **Ambiente**: Happy DOM (simulaÃ§Ã£o de ambiente de navegador)
- **Banco de dados**: PGLite (PostgreSQL para ambiente de navegador)
- **Uso**: Testar componentes frontend, lÃ³gica cliente, componentes React, etc.
- **Arquivo de configuraÃ§Ã£o**: [tests/setup.ts](mdc:tests/setup.ts)

### Ambiente de Teste Servidor (Node Environment)

- **Arquivo de configuraÃ§Ã£o**: [vitest.config.server.ts](mdc:vitest.config.server.ts)
- **Ambiente**: Node.js
- **Banco de dados**: Banco de dados PostgreSQL real
- **LimitaÃ§Ã£o de concorrÃªncia**: ExecuÃ§Ã£o single-thread (`singleFork: true`)
- **Uso**: Testar modelos de banco de dados, lÃ³gica servidor, endpoints de API, etc.
- **Arquivo de configuraÃ§Ã£o**: [tests/setup-db.ts](mdc:tests/setup-db.ts)

## ğŸš€ Comandos de ExecuÃ§Ã£o de Testes

### ExplicaÃ§Ã£o dos Scripts do package.json

Veja os scripts relacionados a testes no [package.json](mdc:package.json):

```json
{
    "test": "npm run test-app && npm run test-server",
    "test-app": "vitest run --config vitest.config.ts",
    "test-app:coverage": "vitest run --config vitest.config.ts --coverage",
    "test-server": "vitest run --config vitest.config.server.ts",
    "test-server:coverage": "vitest run --config vitest.config.server.ts --coverage"
}
```

### Forma Recomendada de ExecuÃ§Ã£o de Testes

#### âœ… Formato de Comando Correto

```bash
# Executar todos os testes cliente
npx vitest run --config vitest.config.ts

# Executar todos os testes servidor
npx vitest run --config vitest.config.server.ts

# Executar arquivo de teste especÃ­fico (suporte a correspondÃªncia difusa)
npx vitest run --config vitest.config.ts basic
npx vitest run --config vitest.config.ts user.test.ts

# Executar linha especÃ­fica de arquivo especÃ­fico
npx vitest run --config vitest.config.ts src/utils/helper.test.ts:25
npx vitest run --config vitest.config.ts basic/foo.test.ts:10,basic/foo.test.ts:25

# Filtrar casos de teste especÃ­ficos por nome
npx vitest -t "test case name" --config vitest.config.ts

# Usar combinaÃ§Ã£o de filtros por arquivo e nome de teste
npx vitest run --config vitest.config.ts filename.test.ts -t "specific test"
```

#### âŒ Formatos de Comando a Evitar

```bash
# âŒ NÃ£o use pnpm test xxx (este nÃ£o Ã© um comando vitest vÃ¡lido)
pnpm test some-file

# âŒ NÃ£o use vitest puro (entrarÃ¡ em modo watch)
vitest test-file.test.ts

# âŒ NÃ£o confunda ambientes de teste
npx vitest run --config vitest.config.server.ts client-component.test.ts
```

### ExplicaÃ§Ã£o dos ParÃ¢metros de ExecuÃ§Ã£o Principais

- **`vitest run`**: Executa os testes uma vez e sai (evita modo watch)
- **`vitest`**: Entra no modo watch por padrÃ£o, monitorando continuamente mudanÃ§as de arquivo
- **`--config`**: Especifica arquivo de configuraÃ§Ã£o, escolhendo o ambiente de teste correto
- **`-t`**: Filtra casos de teste por nome, suporta expressÃµes regulares
- **`--coverage`**: Gera relatÃ³rio de cobertura de teste

## ğŸ”§ PrincÃ­pios de CorreÃ§Ã£o de Testes

### PrincÃ­pios Fundamentais âš ï¸

1. **Leia completamente o cÃ³digo de teste**: Antes de corrigir testes, deve compreender totalmente a intenÃ§Ã£o e implementaÃ§Ã£o do teste
2. **Priorize a correÃ§Ã£o do teste**: Se o prÃ³prio teste estiver errado, modifique o teste em vez do cÃ³digo de implementaÃ§Ã£o
3. **Foque em um Ãºnico problema**: Corrija apenas o teste especificado, nÃ£o adicione testes ou funcionalidades extras
4. **NÃ£o tome iniciativas prÃ³prias**: NÃ£o modifique diretamente ao descobrir outros problemas, proponha primeiro para discussÃ£o

### Fluxo de CorreÃ§Ã£o de Testes

```mermaid
flowchart TD
    subgraph "Etapa 1: AnÃ¡lise e ReproduÃ§Ã£o"
        A[InÃ­cio: Recebido relatÃ³rio de falha de teste] --> B[Localizar e executar teste com falha];
        B --> C{Consegue reproduzir localmente?};
        C -->|NÃ£o| D[Verificar ambiente/configuraÃ§Ã£o/dependÃªncias de teste];
        C -->|Sim| E[Analisar: Ler cÃ³digo de teste, logs de erro, histÃ³rico Git];
    end

    subgraph "Etapa 2: DiagnÃ³stico e Debug"
        E --> F[Estabelecer hipÃ³tese: Problema estÃ¡ no teste, cÃ³digo ou ambiente?];
        F --> G["Debug: Usar console.log ou debugger para inspeÃ§Ã£o profunda"];
        G --> H{HipÃ³tese foi confirmada?};
        H -->|NÃ£o, nova hipÃ³tese| F;
    end

    subgraph "Etapa 3: CorreÃ§Ã£o e ValidaÃ§Ã£o"
        H -->|Sim| I{Determinar causa raiz};
        I -->|Erro lÃ³gico no teste| J[Corrigir cÃ³digo de teste];
        I -->|Bug no cÃ³digo de implementaÃ§Ã£o| K[Corrigir cÃ³digo de implementaÃ§Ã£o];
        I -->|Problema de ambiente/configuraÃ§Ã£o| L[Corrigir configuraÃ§Ã£o ou dependÃªncias];
        J --> M[Validar correÃ§Ã£o: Re-executar teste com falha];
        K --> M;
        L --> M;
        M --> N{Teste passou?};
        N -->|NÃ£o, correÃ§Ã£o ineficaz| F;
        N -->|Sim| O[Expandir validaÃ§Ã£o: Executar todos os testes do arquivo atual];
        O --> P{Todos passaram?};
        P -->|NÃ£o, introduziu novos problemas| F;
    end

    subgraph "Etapa 4: Resumo"
        P -->|Sim| Q[ConcluÃ­do: Escrever resumo da correÃ§Ã£o];
    end

    D --> F;
```

### Resumo ApÃ³s ConclusÃ£o da CorreÃ§Ã£o

ApÃ³s concluir a correÃ§Ã£o do teste, deve fornecer uma breve explicaÃ§Ã£o, incluindo:

1. **AnÃ¡lise da causa do erro**: Explicar a causa raiz da falha do teste
    - Erro lÃ³gico no teste
    - Bug no cÃ³digo de implementaÃ§Ã£o
    - Problema de configuraÃ§Ã£o do ambiente
    - Problema causado por mudanÃ§as de dependÃªncias

2. **ExplicaÃ§Ã£o do mÃ©todo de correÃ§Ã£o**: Descrever brevemente o mÃ©todo de correÃ§Ã£o adotado
    - Quais arquivos foram modificados
    - Qual soluÃ§Ã£o foi adotada
    - Por que escolheu esse mÃ©todo de correÃ§Ã£o

**Formato de exemplo**:

```markdown
## Resumo da CorreÃ§Ã£o de Teste

**Causa do erro**: O formato dos dados mock no teste nÃ£o correspondia ao formato real de retorno da API, causando falha na asserÃ§Ã£o.

**MÃ©todo de correÃ§Ã£o**: Atualizou a estrutura dos dados mock no arquivo de teste para manter consistÃªncia com o formato mais recente de resposta da API. Especificamente modificou a estrutura do objeto `mockUserData` em `user.test.ts`.
```

## ğŸ“‚ OrganizaÃ§Ã£o de Arquivos de Teste

### ConvenÃ§Ãµes de Nomenclatura de Arquivos

- **Testes cliente**: `*.test.ts`, `*.test.tsx` (qualquer localizaÃ§Ã£o)
- **Testes servidor**: `src/database/models/**/*.test.ts`, `src/database/server/**/*.test.ts` (caminhos limitados)

### Estilo de OrganizaÃ§Ã£o de Arquivos de Teste

O projeto adota o estilo de organizaÃ§Ã£o **arquivos de teste no mesmo diretÃ³rio que os arquivos fonte**:

- Arquivos de teste sÃ£o colocados no mesmo diretÃ³rio que os arquivos fonte correspondentes
- Formato de nomenclatura: `nomeArquivoOriginal.test.ts` ou `nomeArquivoOriginal.test.tsx`

Por exemplo:

```
src/components/Button/
â”œâ”€â”€ index.tsx           # Arquivo fonte
â””â”€â”€ index.test.tsx      # Arquivo de teste
```

## ğŸ› ï¸ TÃ©cnicas de Debug de Teste

### Passos para Executar Testes com Falha

1. **Determinar tipo de teste**: Verificar o caminho do arquivo para determinar qual configuraÃ§Ã£o usar
2. **Executar teste individual**: Usar parÃ¢metro `-t` para isolar o problema
3. **Verificar logs de erro**: Ler cuidadosamente mensagens de erro e stack trace
4. **Verificar registros de modificaÃ§Ãµes recentes**: Verificar mudanÃ§as recentes em arquivos relacionados
5. **Adicionar logs de debug**: Adicionar `console.log` nos testes para entender o fluxo de execuÃ§Ã£o

### EstratÃ©gias de Teste para Interfaces IPC do Electron ğŸ–¥ï¸

Para testes envolvendo interfaces IPC do Electron, devido Ã  complexidade de fornecer um ambiente Electron real, adotamos a abordagem de **Mock de valores de retorno** para teste.

#### ConfiguraÃ§Ã£o BÃ¡sica de Mock

```typescript
import { vi } from "vitest";
import { electronIpcClient } from "@/server/modules/ElectronIPCClient";

// Mock do cliente IPC do Electron
vi.mock("@/server/modules/ElectronIPCClient", () => ({
    electronIpcClient: {
        getFilePathById: vi.fn(),
        deleteFiles: vi.fn(),
        // Adicionar outros mÃ©todos IPC conforme necessÃ¡rio
    },
}));
```

#### Configurando Comportamento Mock nos Testes

```typescript
beforeEach(() => {
    // Resetar todos os Mocks
    vi.resetAllMocks();

    // Configurar valores de retorno Mock padrÃ£o
    vi.mocked(electronIpcClient.getFilePathById).mockResolvedValue(
        "/path/to/file.txt"
    );
    vi.mocked(electronIpcClient.deleteFiles).mockResolvedValue({
        success: true,
    });
});
```

#### Exemplos de Teste para Diferentes CenÃ¡rios

```typescript
it("deve processar situaÃ§Ã£o de exclusÃ£o de arquivo bem-sucedida", async () => {
    // Configurar Mock para cenÃ¡rio de sucesso
    vi.mocked(electronIpcClient.deleteFiles).mockResolvedValue({
        success: true,
    });

    const result = await service.deleteFiles(["desktop://file1.txt"]);

    expect(electronIpcClient.deleteFiles).toHaveBeenCalledWith([
        "desktop://file1.txt",
    ]);
    expect(result.success).toBe(true);
});

it("deve processar situaÃ§Ã£o de falha na exclusÃ£o de arquivo", async () => {
    // Configurar Mock para cenÃ¡rio de falha
    vi.mocked(electronIpcClient.deleteFiles).mockRejectedValue(
        new Error("ExclusÃ£o falhou")
    );

    const result = await service.deleteFiles(["desktop://file1.txt"]);

    expect(result.success).toBe(false);
    expect(result.errors).toBeDefined();
});
```

#### Vantagens da EstratÃ©gia Mock

1. **SimplificaÃ§Ã£o do ambiente**: Evita a complexidade de configurar um ambiente Electron
2. **Testes controlÃ¡veis**: Permite controle preciso dos valores de retorno e comportamentos das chamadas IPC
3. **Cobertura de cenÃ¡rios**: FÃ¡cil de testar vÃ¡rios cenÃ¡rios de sucesso/falha
4. **Velocidade de execuÃ§Ã£o**: Chamadas Mock sÃ£o mais rÃ¡pidas que chamadas IPC reais

#### ConsideraÃ§Ãµes Importantes

- **PrecisÃ£o do Mock**: Garantir que o comportamento do Mock seja consistente com o comportamento real da interface IPC
- **SeguranÃ§a de tipos**: Usar `vi.mocked()` para garantir seguranÃ§a de tipos
- **Reset de Mock**: Resetar estado Mock no `beforeEach` para evitar interferÃªncia entre testes
- **ValidaÃ§Ã£o de chamadas**: NÃ£o apenas validar valores de retorno, mas tambÃ©m verificar se mÃ©todos IPC sÃ£o chamados corretamente

### Verificar Registros de ModificaÃ§Ãµes Recentes ğŸ”

Para melhor julgar a causa raiz da falha do teste, Ã© necessÃ¡rio **verificar sistematicamente o histÃ³rico de modificaÃ§Ãµes de arquivos relacionados**. Este Ã© um passo chave para localizar problemas.

#### Primeiro Passo: Determinar o Escopo de Arquivos a Verificar

1. **O prÃ³prio arquivo de teste**: `path/to/component.test.ts`
2. **Arquivo de implementaÃ§Ã£o correspondente**: `path/to/component.ts` ou `path/to/component/index.ts`
3. **Arquivos de dependÃªncia relacionados**: Outros mÃ³dulos importados no teste ou implementaÃ§Ã£o

#### Segundo Passo: Verificar Status do DiretÃ³rio de Trabalho Atual

```bash
# Ver status de todas as modificaÃ§Ãµes nÃ£o commitadas
git status

# Focar se arquivos de teste e implementaÃ§Ã£o tÃªm modificaÃ§Ãµes nÃ£o commitadas
git status | grep -E "(test|spec)"
```

#### Terceiro Passo: Verificar ConteÃºdo de ModificaÃ§Ãµes NÃ£o Commitadas

```bash
# Ver modificaÃ§Ãµes nÃ£o commitadas do arquivo de teste (Ã¡rea de trabalho vs Ã¡rea de stage)
git diff path/to/component.test.ts | cat

# Ver modificaÃ§Ãµes nÃ£o commitadas do arquivo de implementaÃ§Ã£o correspondente
git diff path/to/component.ts | cat

# Ver modificaÃ§Ãµes em stage mas nÃ£o commitadas
git diff --cached path/to/component.test.ts | cat
git diff --cached path/to/component.ts | cat
```

#### ç¬¬å››æ­¥ï¼šæ£€æŸ¥æäº¤å†å²å’Œæ—¶é—´ç›¸å…³æ€§

**é¦–å…ˆæŸ¥çœ‹æäº¤æ—¶é—´ï¼Œåˆ¤æ–­ä¿®æ”¹çš„æ—¶æ•ˆæ€§**ï¼š

```bash
# æŸ¥çœ‹æµ‹è¯•æ–‡ä»¶çš„æœ€è¿‘æäº¤å†å²ï¼ŒåŒ…å«æäº¤æ—¶é—´
git log --pretty=format:"%h %ad %s" --date=relative -5 path/to/component.test.ts | cat

# æŸ¥çœ‹å®ç°æ–‡ä»¶çš„æœ€è¿‘æäº¤å†å²ï¼ŒåŒ…å«æäº¤æ—¶é—´
git log --pretty=format:"%h %ad %s" --date=relative -5 path/to/component.ts | cat

# æŸ¥çœ‹è¯¦ç»†çš„æäº¤æ—¶é—´ï¼ˆISOæ ¼å¼ï¼Œä¾¿äºç²¾ç¡®åˆ¤æ–­ï¼‰
git log --pretty=format:"%h %ad %an %s" --date=iso -3 path/to/component.ts | cat
git log --pretty=format:"%h %ad %an %s" --date=iso -3 path/to/component.test.ts | cat
```

**åˆ¤æ–­æäº¤çš„å‚è€ƒä»·å€¼**ï¼š

1. **æœ€è¿‘æäº¤ï¼ˆ24å°æ—¶å†…ï¼‰**: ğŸ”´ **é«˜åº¦ç›¸å…³** - å¾ˆå¯èƒ½æ˜¯å¯¼è‡´æµ‹è¯•å¤±è´¥çš„ç›´æ¥åŸå› 
2. **è¿‘æœŸæäº¤ï¼ˆ1-7å¤©å†…ï¼‰**: ğŸŸ¡ **ä¸­ç­‰ç›¸å…³** - å¯èƒ½ç›¸å…³ï¼Œéœ€è¦ä»”ç»†åˆ†æä¿®æ”¹å†…å®¹
3. **è¾ƒæ—©æäº¤ï¼ˆè¶…è¿‡1å‘¨ï¼‰**: âšª **ä½ç›¸å…³æ€§** - é™¤éæ˜¯é‡å¤§é‡æ„ï¼Œå¦åˆ™ä¸å¤ªå¯èƒ½æ˜¯ç›´æ¥åŸå› 

#### ç¬¬äº”æ­¥ï¼šåŸºäºæ—¶é—´ç›¸å…³æ€§æŸ¥çœ‹å…·ä½“ä¿®æ”¹å†…å®¹

**æ ¹æ®æäº¤æ—¶é—´çš„è¿œè¿‘ï¼Œä¼˜å…ˆæŸ¥çœ‹æœ€è¿‘çš„ä¿®æ”¹**ï¼š

```bash
# å¦‚æœæœ‰24å°æ—¶å†…çš„æäº¤ï¼Œé‡ç‚¹æŸ¥çœ‹è¿™äº›ä¿®æ”¹
git show HEAD -- path/to/component.test.ts | cat
git show HEAD -- path/to/component.ts | cat

# æŸ¥çœ‹æ¬¡æ–°çš„æäº¤ï¼ˆå¦‚æœæœ€æ–°æäº¤æ—¶é—´è¾ƒè¿œï¼‰
git show HEAD~1 -- path/to/component.ts | cat
git show <recent-commit-hash> -- path/to/component.ts | cat

# å¯¹æ¯”æœ€è¿‘ä¸¤æ¬¡æäº¤çš„å·®å¼‚
git diff HEAD~1 HEAD -- path/to/component.ts | cat
```

#### ç¬¬å…­æ­¥ï¼šåˆ†æä¿®æ”¹ä¸æµ‹è¯•å¤±è´¥çš„å…³ç³»

åŸºäºä¿®æ”¹è®°å½•å’Œæ—¶é—´ç›¸å…³æ€§åˆ¤æ–­ï¼š

1. **æœ€è¿‘ä¿®æ”¹äº†å®ç°ä»£ç **:

    ```bash
    # é‡ç‚¹æ£€æŸ¥å®ç°é€»è¾‘çš„å˜åŒ–
    git diff HEAD~1 path/to/component.ts | cat
    ```

    - å¾ˆå¯èƒ½æ˜¯å®ç°ä»£ç çš„å˜æ›´å¯¼è‡´æµ‹è¯•å¤±è´¥
    - æ£€æŸ¥å®ç°é€»è¾‘æ˜¯å¦æ­£ç¡®
    - ç¡®è®¤æµ‹è¯•æ˜¯å¦éœ€è¦ç›¸åº”æ›´æ–°

2. **æœ€è¿‘ä¿®æ”¹äº†æµ‹è¯•ä»£ç **:

    ```bash
    # é‡ç‚¹æ£€æŸ¥æµ‹è¯•é€»è¾‘çš„å˜åŒ–
    git diff HEAD~1 path/to/component.test.ts | cat
    ```

    - å¯èƒ½æ˜¯æµ‹è¯•æœ¬èº«å†™é”™äº†
    - æ£€æŸ¥æµ‹è¯•é€»è¾‘å’Œæ–­è¨€æ˜¯å¦æ­£ç¡®
    - ç¡®è®¤æµ‹è¯•æ˜¯å¦ç¬¦åˆå®ç°çš„é¢„æœŸè¡Œä¸º

3. **ä¸¤è€…éƒ½æœ‰æœ€è¿‘ä¿®æ”¹**:

    ```bash
    # å¯¹æ¯”ä¸¤ä¸ªæ–‡ä»¶çš„ä¿®æ”¹æ—¶é—´
    git log --pretty=format:"%ad %f" --date=iso -1 path/to/component.ts | cat
    git log --pretty=format:"%ad %f" --date=iso -1 path/to/component.test.ts | cat
    ```

    - éœ€è¦ç»¼åˆåˆ†æä¸¤è€…çš„ä¿®æ”¹
    - ç¡®å®šå“ªä¸ªä¿®æ”¹æ›´å¯èƒ½å¯¼è‡´é—®é¢˜
    - ä¼˜å…ˆæ£€æŸ¥æ—¶é—´æ›´è¿‘çš„ä¿®æ”¹

4. **éƒ½æ²¡æœ‰æœ€è¿‘ä¿®æ”¹**:
    - å¯èƒ½æ˜¯ä¾èµ–å˜æ›´æˆ–ç¯å¢ƒé—®é¢˜
    - æ£€æŸ¥ `package.json`ã€é…ç½®æ–‡ä»¶ç­‰çš„ä¿®æ”¹
    - æŸ¥çœ‹æ˜¯å¦æœ‰å…¨å±€æ€§çš„ä»£ç é‡æ„

#### ä¿®æ”¹è®°å½•æ£€æŸ¥ç¤ºä¾‹

```bash
# å®Œæ•´çš„æ£€æŸ¥æµç¨‹ç¤ºä¾‹
echo "=== æ£€æŸ¥æ–‡ä»¶ä¿®æ”¹çŠ¶æ€ ==="
git status | grep component

echo "=== æ£€æŸ¥æœªæäº¤ä¿®æ”¹ ==="
git diff src/components/Button/index.test.tsx | cat
git diff src/components/Button/index.tsx | cat

echo "=== æ£€æŸ¥æäº¤å†å²å’Œæ—¶é—´ ==="
git log --pretty=format:"%h %ad %s" --date=relative -3 src/components/Button/index.test.tsx | cat
git log --pretty=format:"%h %ad %s" --date=relative -3 src/components/Button/index.tsx | cat

echo "=== æ ¹æ®æ—¶é—´ä¼˜å…ˆçº§æŸ¥çœ‹ä¿®æ”¹å†…å®¹ ==="
# å¦‚æœæœ‰24å°æ—¶å†…çš„æäº¤ï¼Œé‡ç‚¹æŸ¥çœ‹
git show HEAD -- src/components/Button/index.tsx | cat
```

## ğŸ—ƒï¸ æ•°æ®åº“ Model æµ‹è¯•æŒ‡å—

### æµ‹è¯•ç¯å¢ƒé€‰æ‹© ğŸ’¡

æ•°æ®åº“ Model å±‚é€šè¿‡ç¯å¢ƒå˜é‡æ§åˆ¶æ•°æ®åº“ç±»å‹ï¼Œåœ¨ä¸¤ç§æµ‹è¯•ç¯å¢ƒä¸‹æœ‰ä¸åŒçš„æ•°æ®åº“åç«¯ï¼šå®¢æˆ·ç«¯ç¯å¢ƒ (PGLite) å’Œ æœåŠ¡ç«¯ç¯å¢ƒ (PostgreSQL)

### âš ï¸ åŒç¯å¢ƒéªŒè¯è¦æ±‚

**å¯¹äºæ‰€æœ‰ Model æµ‹è¯•ï¼Œå¿…é¡»åœ¨ä¸¤ä¸ªç¯å¢ƒä¸‹éƒ½éªŒè¯é€šè¿‡**ï¼š

#### å®Œæ•´éªŒè¯æµç¨‹

```bash
# 1. å…ˆåœ¨å®¢æˆ·ç«¯ç¯å¢ƒæµ‹è¯•ï¼ˆå¿«é€ŸéªŒè¯ï¼‰
npx vitest run --config vitest.config.ts src/database/models/__tests__/myModel.test.ts

# 2. å†åœ¨æœåŠ¡ç«¯ç¯å¢ƒæµ‹è¯•ï¼ˆå…¼å®¹æ€§éªŒè¯ï¼‰
npx vitest run --config vitest.config.server.ts src/database/models/__tests__/myModel.test.ts
```

### åˆ›å»ºæ–° Model æµ‹è¯•çš„æœ€ä½³å®è·µ ğŸ“‹

#### 1. å‚è€ƒç°æœ‰å®ç°å’Œæµ‹è¯•æ¨¡æ¿

åˆ›å»ºæ–° Model æµ‹è¯•å‰ï¼Œ**å¿…é¡»å…ˆå‚è€ƒç°æœ‰çš„å®ç°æ¨¡å¼**ï¼š

- **Model å®ç°å‚è€ƒ**: 
- **æµ‹è¯•æ¨¡æ¿å‚è€ƒ**: 
- **å¤æ‚ç¤ºä¾‹å‚è€ƒ**: 

#### 2. ç”¨æˆ·æƒé™æ£€æŸ¥ - å®‰å…¨ç¬¬ä¸€ ğŸ”’

è¿™æ˜¯**æœ€å…³é”®çš„å®‰å…¨è¦æ±‚**ã€‚æ‰€æœ‰æ¶‰åŠç”¨æˆ·æ•°æ®çš„æ“ä½œéƒ½å¿…é¡»åŒ…å«ç”¨æˆ·æƒé™æ£€æŸ¥ï¼š

**âŒ é”™è¯¯ç¤ºä¾‹ - å­˜åœ¨å®‰å…¨æ¼æ´**:

```typescript
// å±é™©ï¼šç¼ºå°‘ç”¨æˆ·æƒé™æ£€æŸ¥ï¼Œä»»ä½•ç”¨æˆ·éƒ½èƒ½æ“ä½œä»»ä½•æ•°æ®
update = async (id: string, data: Partial<MyModel>) => {
    return this.db
        .update(myTable)
        .set(data)
        .where(eq(myTable.id, id)) // âŒ åªæ£€æŸ¥ IDï¼Œæ²¡æœ‰æ£€æŸ¥ userId
        .returning();
};
```

**âœ… æ­£ç¡®ç¤ºä¾‹ - å®‰å…¨çš„å®ç°**:

```typescript
// å®‰å…¨ï¼šå¿…é¡»åŒæ—¶åŒ¹é… ID å’Œ userId
update = async (id: string, data: Partial<MyModel>) => {
    return this.db
        .update(myTable)
        .set(data)
        .where(
            and(
                eq(myTable.id, id),
                eq(myTable.userId, this.userId) // âœ… ç”¨æˆ·æƒé™æ£€æŸ¥
            )
        )
        .returning();
};
```

**å¿…é¡»è¿›è¡Œç”¨æˆ·æƒé™æ£€æŸ¥çš„æ–¹æ³•**ï¼š

- `update()` - æ›´æ–°æ“ä½œ
- `delete()` - åˆ é™¤æ“ä½œ
- `findById()` - æŸ¥æ‰¾ç‰¹å®šè®°å½•
- ä»»ä½•æ¶‰åŠç‰¹å®šè®°å½•çš„æŸ¥è¯¢æˆ–ä¿®æ”¹æ“ä½œ

#### 3. æµ‹è¯•æ–‡ä»¶ç»“æ„å’Œå¿…æµ‹åœºæ™¯

**åŸºæœ¬æµ‹è¯•ç»“æ„**:

```typescript
// @vitest-environment node
describe("MyModel", () => {
    describe("create", () => {
        it("should create a new record");
        it("should handle edge cases");
    });

    describe("queryAll", () => {
        it("should return records for current user only");
        it("should handle empty results");
    });

    describe("update", () => {
        it("should update own records");
        it("should NOT update other users records"); // ğŸ”’ å®‰å…¨æµ‹è¯•
    });

    describe("delete", () => {
        it("should delete own records");
        it("should NOT delete other users records"); // ğŸ”’ å®‰å…¨æµ‹è¯•
    });

    describe("user isolation", () => {
        it("should enforce user data isolation"); // ğŸ”’ æ ¸å¿ƒå®‰å…¨æµ‹è¯•
    });
});
```

**å¿…é¡»æµ‹è¯•çš„å®‰å…¨åœºæ™¯** ğŸ”’:

```typescript
it("should not update records of other users", async () => {
    // åˆ›å»ºå…¶ä»–ç”¨æˆ·çš„è®°å½•
    const [otherUserRecord] = await serverDB
        .insert(myTable)
        .values({ userId: "other-user", data: "original" })
        .returning();

    // å°è¯•æ›´æ–°å…¶ä»–ç”¨æˆ·çš„è®°å½•
    const result = await myModel.update(otherUserRecord.id, { data: "hacked" });

    // åº”è¯¥è¿”å› undefined æˆ–ç©ºæ•°ç»„ï¼ˆå› ä¸ºæƒé™æ£€æŸ¥å¤±è´¥ï¼‰
    expect(result).toBeUndefined();

    // éªŒè¯åŸå§‹æ•°æ®æœªè¢«ä¿®æ”¹
    const unchanged = await serverDB.query.myTable.findFirst({
        where: eq(myTable.id, otherUserRecord.id),
    });
    expect(unchanged?.data).toBe("original"); // æ•°æ®åº”è¯¥ä¿æŒä¸å˜
});
```

#### 4. Mock å¤–éƒ¨ä¾èµ–æœåŠ¡

å¦‚æœ Model ä¾èµ–å¤–éƒ¨æœåŠ¡ï¼ˆå¦‚ FileServiceï¼‰ï¼Œéœ€è¦æ­£ç¡® Mockï¼š

**è®¾ç½® Mock**:

```typescript
// åœ¨æ–‡ä»¶é¡¶éƒ¨è®¾ç½® Mock
const mockGetFullFileUrl = vi.fn();
vi.mock("@/server/services/file", () => ({
    FileService: vi.fn().mockImplementation(() => ({
        getFullFileUrl: mockGetFullFileUrl,
    })),
}));

// åœ¨ beforeEach ä¸­é‡ç½®å’Œé…ç½® Mock
beforeEach(async () => {
    vi.clearAllMocks();
    mockGetFullFileUrl.mockImplementation(
        (url: string) => `https://example.com/${url}`
    );
});
```

**éªŒè¯ Mock è°ƒç”¨**:

```typescript
it("should process URLs through FileService", async () => {
    // ... æµ‹è¯•é€»è¾‘

    // éªŒè¯ Mock è¢«æ­£ç¡®è°ƒç”¨
    expect(mockGetFullFileUrl).toHaveBeenCalledWith("expected-url");
    expect(mockGetFullFileUrl).toHaveBeenCalledTimes(1);
});
```

#### 5. æ•°æ®åº“çŠ¶æ€ç®¡ç†

**æ­£ç¡®çš„æ•°æ®æ¸…ç†æ¨¡å¼**:

```typescript
const userId = "test-user";
const otherUserId = "other-user";

beforeEach(async () => {
    // æ¸…ç†ç”¨æˆ·è¡¨ï¼ˆçº§è”åˆ é™¤ç›¸å…³æ•°æ®ï¼‰
    await serverDB.delete(users);

    // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
    await serverDB.insert(users).values([{ id: userId }, { id: otherUserId }]);
});

afterEach(async () => {
    // æ¸…ç†æµ‹è¯•æ•°æ®
    await serverDB.delete(users);
});
```

#### 6. æµ‹è¯•æ•°æ®ç±»å‹å’Œå¤–é”®çº¦æŸå¤„ç† âš ï¸

**å¿…é¡»ä½¿ç”¨ Schema å¯¼å‡ºçš„ç±»å‹**:

```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨ schema å¯¼å‡ºçš„ç±»å‹
import { NewGenerationBatch, NewGeneration } from '../../schemas';

const testBatch: NewGenerationBatch = {
    userId,
    generationTopicId: 'test-topic-id',
    provider: 'test-provider',
    model: 'test-model',
    prompt: 'Test prompt for image generation',
    width: 1024,
    height: 1024,
    config: { /* ... */ },
};

const testGeneration: NewGeneration = {
    id: 'test-gen-id',
    generationBatchId: 'test-batch-id',
    asyncTaskId: null, // å¤„ç†å¤–é”®çº¦æŸ
    fileId: null,      // å¤„ç†å¤–é”®çº¦æŸ
    seed: 12345,
    userId,
};
```

```typescript
// âŒ é”™è¯¯ï¼šæ²¡æœ‰ç±»å‹å£°æ˜æˆ–ä½¿ç”¨é”™è¯¯ç±»å‹
const testBatch = {  // ç¼ºå°‘ç±»å‹å£°æ˜
    generationTopicId: 'test-topic-id',
    // ...
};

const testGeneration = {  // ç¼ºå°‘ç±»å‹å£°æ˜
    asyncTaskId: 'invalid-uuid',  // å¤–é”®çº¦æŸé”™è¯¯
    fileId: 'non-existent-file',  // å¤–é”®çº¦æŸé”™è¯¯
    // ...
};
```

**å¤–é”®çº¦æŸå¤„ç†ç­–ç•¥**:

1. **ä½¿ç”¨ null å€¼**: å¯¹äºå¯é€‰çš„å¤–é”®å­—æ®µï¼Œä½¿ç”¨ null é¿å…çº¦æŸé”™è¯¯
2. **åˆ›å»ºå…³è”è®°å½•**: å¦‚æœéœ€è¦æµ‹è¯•å…³è”å…³ç³»ï¼Œå…ˆåˆ›å»ºè¢«å¼•ç”¨çš„è®°å½•
3. **ç†è§£çº¦æŸå…³ç³»**: äº†è§£å“ªäº›å­—æ®µæœ‰å¤–é”®çº¦æŸï¼Œé¿å…å¼•ç”¨ä¸å­˜åœ¨çš„è®°å½•

```typescript
// å¤–é”®çº¦æŸå¤„ç†ç¤ºä¾‹
beforeEach(async () => {
    // æ¸…ç†æ•°æ®åº“
    await serverDB.delete(users);
    
    // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
    await serverDB.insert(users).values([{ id: userId }]);
    
    // å¦‚æœéœ€è¦æµ‹è¯•æ–‡ä»¶å…³è”ï¼Œåˆ›å»ºæ–‡ä»¶è®°å½•
    if (needsFileAssociation) {
        await serverDB.insert(files).values({
            id: 'test-file-id',
            userId,
            name: 'test.jpg',
            url: 'test-url',
            size: 1024,
            fileType: 'image/jpeg',
        });
    }
});
```

**æ’åºæµ‹è¯•çš„å¯é¢„æµ‹æ€§**:

```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨æ˜ç¡®çš„æ—¶é—´æˆ³ç¡®ä¿æ’åºç»“æœå¯é¢„æµ‹
it('should find batches by topic id in correct order', async () => {
    const oldDate = new Date('2024-01-01T10:00:00Z');
    const newDate = new Date('2024-01-02T10:00:00Z');
    
    const batch1 = { ...testBatch, prompt: 'First batch', userId, createdAt: oldDate };
    const batch2 = { ...testBatch, prompt: 'Second batch', userId, createdAt: newDate };

    await serverDB.insert(generationBatches).values([batch1, batch2]);

    const results = await generationBatchModel.findByTopicId(testTopic.id);

    expect(results[0].prompt).toBe('Second batch'); // æœ€æ–°ä¼˜å…ˆ (desc order)
    expect(results[1].prompt).toBe('First batch');
});
```

```typescript
// âŒ é”™è¯¯ï¼šä¾èµ–æ•°æ®åº“çš„é»˜è®¤æ—¶é—´æˆ³ï¼Œç»“æœä¸å¯é¢„æµ‹
it('should find batches by topic id', async () => {
    const batch1 = { ...testBatch, prompt: 'First batch', userId };
    const batch2 = { ...testBatch, prompt: 'Second batch', userId };

    await serverDB.insert(generationBatches).values([batch1, batch2]);
    
    // æ’å…¥é¡ºåºå’Œæ•°æ®åº“æ—¶é—´æˆ³å¯èƒ½ä¸ä¸€è‡´ï¼Œå¯¼è‡´æµ‹è¯•ä¸ç¨³å®š
    const results = await generationBatchModel.findByTopicId(testTopic.id);
    expect(results[0].prompt).toBe('Second batch'); // å¯èƒ½å¤±è´¥
});
```



### å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ ğŸ’¡

#### é—®é¢˜ 1ï¼šæƒé™æ£€æŸ¥ç¼ºå¤±å¯¼è‡´å®‰å…¨æ¼æ´

**ç°è±¡**: æµ‹è¯•å¤±è´¥ï¼Œç”¨æˆ·èƒ½ä¿®æ”¹å…¶ä»–ç”¨æˆ·çš„æ•°æ®
**è§£å†³**: åœ¨ Model çš„ `update` å’Œ `delete` æ–¹æ³•ä¸­æ·»åŠ  `and(eq(table.id, id), eq(table.userId, this.userId))`

#### é—®é¢˜ 2ï¼šMock æœªç”Ÿæ•ˆæˆ–éªŒè¯å¤±è´¥

**ç°è±¡**: `undefined is not a spy` é”™è¯¯
**è§£å†³**: æ£€æŸ¥ Mock è®¾ç½®ä½ç½®å’Œæ–¹å¼ï¼Œç¡®ä¿åœ¨æµ‹è¯•æ–‡ä»¶é¡¶éƒ¨è®¾ç½®ï¼Œåœ¨ `beforeEach` ä¸­é‡ç½®

#### é—®é¢˜ 3ï¼šæµ‹è¯•æ•°æ®æ±¡æŸ“

**ç°è±¡**: æµ‹è¯•é—´ç›¸äº’å½±å“ï¼Œç»“æœä¸ç¨³å®š
**è§£å†³**: åœ¨ `beforeEach` å’Œ `afterEach` ä¸­æ­£ç¡®æ¸…ç†æ•°æ®åº“çŠ¶æ€

#### é—®é¢˜ 4ï¼šå¤–éƒ¨ä¾èµ–å¯¼è‡´æµ‹è¯•å¤±è´¥

**ç°è±¡**: å› ä¸ºçœŸå®çš„å¤–éƒ¨æœåŠ¡è°ƒç”¨å¯¼è‡´æµ‹è¯•ä¸ç¨³å®š
**è§£å†³**: Mock æ‰€æœ‰å¤–éƒ¨ä¾èµ–ï¼Œä½¿æµ‹è¯•æ›´å¯æ§å’Œå¿«é€Ÿ

#### é—®é¢˜ 5ï¼šå¤–é”®çº¦æŸè¿åå¯¼è‡´æµ‹è¯•å¤±è´¥

**ç°è±¡**: `insert or update on table "xxx" violates foreign key constraint`
**è§£å†³**: 
- å°†å¯é€‰å¤–é”®å­—æ®µè®¾ä¸º `null` è€Œä¸æ˜¯æ— æ•ˆçš„å­—ç¬¦ä¸²å€¼
- æˆ–è€…å…ˆåˆ›å»ºè¢«å¼•ç”¨çš„è®°å½•ï¼Œå†åˆ›å»ºå½“å‰è®°å½•

```typescript
// âŒ é”™è¯¯ï¼šæ— æ•ˆçš„å¤–é”®å€¼
const testData = {
    asyncTaskId: 'invalid-uuid',  // è¡¨ä¸­ä¸å­˜åœ¨æ­¤è®°å½•
    fileId: 'non-existent-file',  // è¡¨ä¸­ä¸å­˜åœ¨æ­¤è®°å½•
};

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ null å€¼
const testData = {
    asyncTaskId: null,  // é¿å…å¤–é”®çº¦æŸ
    fileId: null,       // é¿å…å¤–é”®çº¦æŸ
};

// âœ… æˆ–è€…ï¼šå…ˆåˆ›å»ºè¢«å¼•ç”¨çš„è®°å½•
beforeEach(async () => {
    const [asyncTask] = await serverDB.insert(asyncTasks).values({
        id: 'valid-task-id',
        status: 'pending',
        type: 'generation',
    }).returning();
    
    const testData = {
        asyncTaskId: asyncTask.id,  // ä½¿ç”¨æœ‰æ•ˆçš„å¤–é”®å€¼
    };
});
```

#### é—®é¢˜ 6ï¼šæ’åºæµ‹è¯•ç»“æœä¸ä¸€è‡´

**ç°è±¡**: ç›¸åŒçš„æµ‹è¯•æœ‰æ—¶é€šè¿‡ï¼Œæœ‰æ—¶å¤±è´¥ï¼Œç‰¹åˆ«æ˜¯æ¶‰åŠæ’åºçš„æµ‹è¯•
**è§£å†³**: ä½¿ç”¨æ˜ç¡®çš„æ—¶é—´æˆ³ï¼Œä¸è¦ä¾èµ–æ•°æ®åº“çš„é»˜è®¤æ—¶é—´æˆ³

```typescript
// âŒ é”™è¯¯ï¼šä¾èµ–æ’å…¥é¡ºåºå’Œé»˜è®¤æ—¶é—´æˆ³
await serverDB.insert(table).values([data1, data2]);  // æ—¶é—´æˆ³ä¸å¯é¢„æµ‹

// âœ… æ­£ç¡®ï¼šæ˜ç¡®æŒ‡å®šæ—¶é—´æˆ³
const oldDate = new Date('2024-01-01T10:00:00Z');
const newDate = new Date('2024-01-02T10:00:00Z');
await serverDB.insert(table).values([
    { ...data1, createdAt: oldDate },
    { ...data2, createdAt: newDate },
]);
```

#### é—®é¢˜ 7ï¼šMock éªŒè¯å¤±è´¥æˆ–è°ƒç”¨æ¬¡æ•°ä¸åŒ¹é…

**ç°è±¡**: `expect(mockFunction).toHaveBeenCalledWith(...)` å¤±è´¥
**è§£å†³**: 
- æ£€æŸ¥ Mock å‡½æ•°çš„å®é™…è°ƒç”¨å‚æ•°å’ŒæœŸæœ›å‚æ•°æ˜¯å¦å®Œå…¨åŒ¹é…
- ç¡®è®¤ Mock åœ¨æ­£ç¡®çš„æ—¶æœºè¢«é‡ç½®å’Œé…ç½®
- ä½¿ç”¨ `toHaveBeenCalledTimes()` éªŒè¯è°ƒç”¨æ¬¡æ•°

```typescript
// åœ¨ beforeEach ä¸­æ­£ç¡®é…ç½® Mock
beforeEach(() => {
    vi.clearAllMocks();  // é‡ç½®æ‰€æœ‰ Mock
    
    mockGetFullFileUrl.mockImplementation((url: string) => `https://example.com/${url}`);
    mockTransformGeneration.mockResolvedValue({
        id: 'test-id',
        // ... å…¶ä»–å­—æ®µ
    });
});

// æµ‹è¯•ä¸­éªŒè¯ Mock è°ƒç”¨
it('should call FileService with correct parameters', async () => {
    await model.someMethod();
    
    // éªŒè¯è°ƒç”¨å‚æ•°
    expect(mockGetFullFileUrl).toHaveBeenCalledWith('expected-url');
    // éªŒè¯è°ƒç”¨æ¬¡æ•°
    expect(mockGetFullFileUrl).toHaveBeenCalledTimes(1);
});
```

### Model æµ‹è¯•æ£€æŸ¥æ¸…å• âœ…

åˆ›å»º Model æµ‹è¯•æ—¶ï¼Œè¯·ç¡®ä¿ä»¥ä¸‹å„é¡¹éƒ½å·²å®Œæˆï¼š

#### ğŸ”§ åŸºç¡€é…ç½®
- [ ] **åŒç¯å¢ƒéªŒè¯** - åœ¨å®¢æˆ·ç«¯ç¯å¢ƒ (vitest.config.ts) å’ŒæœåŠ¡ç«¯ç¯å¢ƒ (vitest.config.server.ts) ä¸‹éƒ½æµ‹è¯•é€šè¿‡
- [ ] å‚è€ƒäº† `_template.ts` å’Œç°æœ‰ Model çš„å®ç°æ¨¡å¼
- [ ] **ä½¿ç”¨æ­£ç¡®çš„ Schema ç±»å‹** - æµ‹è¯•æ•°æ®ä½¿ç”¨ `NewXxx` ç±»å‹å£°æ˜ï¼Œå¦‚ `NewGenerationBatch`ã€`NewGeneration`

#### ğŸ”’ å®‰å…¨æµ‹è¯•
- [ ] **æ‰€æœ‰æ¶‰åŠç”¨æˆ·æ•°æ®çš„æ“ä½œéƒ½åŒ…å«ç”¨æˆ·æƒé™æ£€æŸ¥**
- [ ] åŒ…å«äº†ç”¨æˆ·æƒé™éš”ç¦»çš„å®‰å…¨æµ‹è¯•
- [ ] æµ‹è¯•äº†ç”¨æˆ·æ— æ³•è®¿é—®å…¶ä»–ç”¨æˆ·æ•°æ®çš„åœºæ™¯

#### ğŸ—ƒï¸ æ•°æ®å¤„ç†
- [ ] **æ­£ç¡®å¤„ç†å¤–é”®çº¦æŸ** - ä½¿ç”¨ `null` å€¼æˆ–å…ˆåˆ›å»ºè¢«å¼•ç”¨è®°å½•
- [ ] **æ’åºæµ‹è¯•ä½¿ç”¨æ˜ç¡®æ—¶é—´æˆ³** - ä¸ä¾èµ–æ•°æ®åº“é»˜è®¤æ—¶é—´ï¼Œç¡®ä¿ç»“æœå¯é¢„æµ‹
- [ ] åœ¨ `beforeEach` å’Œ `afterEach` ä¸­æ­£ç¡®ç®¡ç†æ•°æ®åº“çŠ¶æ€
- [ ] æ‰€æœ‰æµ‹è¯•éƒ½èƒ½ç‹¬ç«‹è¿è¡Œä¸”äº’ä¸å¹²æ‰°

#### ğŸ­ Mock å’Œå¤–éƒ¨ä¾èµ–
- [ ] æ­£ç¡® Mock äº†å¤–éƒ¨ä¾èµ–æœåŠ¡ (å¦‚ FileServiceã€GenerationModel)
- [ ] åœ¨ `beforeEach` ä¸­é‡ç½®å’Œé…ç½® Mock
- [ ] éªŒè¯äº† Mock æœåŠ¡çš„è°ƒç”¨å‚æ•°å’Œæ¬¡æ•°
- [ ] æµ‹è¯•äº†å¤–éƒ¨æœåŠ¡é”™è¯¯åœºæ™¯çš„å¤„ç†

#### ğŸ“‹ æµ‹è¯•è¦†ç›–
- [ ] æµ‹è¯•è¦†ç›–äº†æ‰€æœ‰ä¸»è¦æ–¹æ³• (create, query, update, delete)
- [ ] æµ‹è¯•äº†è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯åœºæ™¯
- [ ] åŒ…å«äº†ç©ºç»“æœå¤„ç†çš„æµ‹è¯•
- [ ] **ç¡®è®¤ä¸¤ä¸ªç¯å¢ƒä¸‹çš„æµ‹è¯•ç»“æœä¸€è‡´**

#### ğŸš¨ å¸¸è§é—®é¢˜æ£€æŸ¥
- [ ] æ²¡æœ‰å¤–é”®çº¦æŸè¿åé”™è¯¯
- [ ] æ’åºæµ‹è¯•ç»“æœç¨³å®šå¯é¢„æµ‹
- [ ] Mock éªŒè¯æ— å¤±è´¥
- [ ] æ— æµ‹è¯•æ•°æ®æ±¡æŸ“é—®é¢˜

### å®‰å…¨è­¦å‘Š âš ï¸

**æ•°æ®åº“ Model å±‚æ˜¯å®‰å…¨çš„ç¬¬ä¸€é“é˜²çº¿**ã€‚å¦‚æœ Model å±‚ç¼ºå°‘ç”¨æˆ·æƒé™æ£€æŸ¥ï¼š

1. **ä»»ä½•ç”¨æˆ·éƒ½èƒ½è®¿é—®å’Œä¿®æ”¹å…¶ä»–ç”¨æˆ·çš„æ•°æ®**
2. **å³ä½¿ä¸Šå±‚æœ‰æƒé™æ£€æŸ¥ï¼Œä¹Ÿå¯èƒ½è¢«ç»•è¿‡**
3. **å¯èƒ½å¯¼è‡´ä¸¥é‡çš„æ•°æ®æ³„éœ²å’Œå®‰å…¨äº‹æ•…**

å› æ­¤ï¼Œ**æ¯ä¸ªæ¶‰åŠç”¨æˆ·æ•°æ®çš„ Model æ–¹æ³•éƒ½å¿…é¡»åŒ…å«ç”¨æˆ·æƒé™æ£€æŸ¥ï¼Œä¸”å¿…é¡»æœ‰å¯¹åº”çš„å®‰å…¨æµ‹è¯•æ¥éªŒè¯è¿™äº›æ£€æŸ¥çš„æœ‰æ•ˆæ€§**ã€‚

## ğŸ¯ æ€»ç»“

ä¿®å¤æµ‹è¯•æ—¶ï¼Œè®°ä½ä»¥ä¸‹å…³é”®ç‚¹ï¼š

- **ä½¿ç”¨æ­£ç¡®çš„å‘½ä»¤**: `npx vitest run --config [config-file]`
- **ç†è§£æµ‹è¯•æ„å›¾**: å…ˆè¯»æ‡‚æµ‹è¯•å†ä¿®å¤
- **æŸ¥çœ‹æœ€è¿‘ä¿®æ”¹**: æ£€æŸ¥ç›¸å…³æ–‡ä»¶çš„ git ä¿®æ”¹è®°å½•ï¼Œåˆ¤æ–­é—®é¢˜æ ¹æº
- **é€‰æ‹©æ­£ç¡®ç¯å¢ƒ**: å®¢æˆ·ç«¯æµ‹è¯•ç”¨ `vitest.config.ts`ï¼ŒæœåŠ¡ç«¯ç”¨ `vitest.config.server.ts`
- **ä¸“æ³¨å•ä¸€é—®é¢˜**: åªä¿®å¤å½“å‰çš„æµ‹è¯•å¤±è´¥
- **éªŒè¯ä¿®å¤ç»“æœ**: ç¡®ä¿ä¿®å¤åæµ‹è¯•é€šè¿‡ä¸”æ— å‰¯ä½œç”¨
- **æä¾›ä¿®å¤æ€»ç»“**: è¯´æ˜é”™è¯¯åŸå› å’Œä¿®å¤æ–¹æ³•
- **Model æµ‹è¯•å®‰å…¨ç¬¬ä¸€**: å¿…é¡»åŒ…å«ç”¨æˆ·æƒé™æ£€æŸ¥å’Œå¯¹åº”çš„å®‰å…¨æµ‹è¯•
- **Model åŒç¯å¢ƒéªŒè¯**: å¿…é¡»åœ¨ PGLite å’Œ PostgreSQL ä¸¤ä¸ªç¯å¢ƒä¸‹éƒ½éªŒè¯é€šè¿‡
